package main

import (
    "fmt"
    "time"
	log "github.com/sirupsen/logrus"
    "bytes"
    "github.com/gorilla/websocket"
)

const (
    writeWait = 10 * time.Second

    pongWait = 60 * time.Second

    maxMessageSize = 1024

    // dispatchTable is a map (dict) of ints to (anonymous) functions that take maps of ints to 
    // arbitrary data types, and return booleans
    dispatchTable = map[int]func(*Client, map[int]interface{})bool{
        112: func(c *Client, x map[int]interface{}) {
            return c.handle112(x)
        }
    }
)

var (
    newline = []byte{'\n'}
    space   = []byte{' '}
)

type clientID string

type Client struct {
    // socket is the websocket for this client
    conn *websocket.Conn

    // send is a channel on which messages are sent
    send chan []byte

	// the clientID is a unique uuid generated by the server and stored by the web client
    cid clientID

    // the uid identifies the user using this client?
    //uid userID

    // the Roster object that tracks active users
    roster *Roster
}


func (c *Client) readWorker() {
    defer c.conn.Close()

    c.conn.SetReadLimit(maxMessageSize)
    c.conn.SetReadDeadline(time.Now().Add(pongWait))
    c.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })
    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway) {
                log.Printf("error: %v", err)
            }
            break
        }
        message = bytes.TrimSpace(bytes.Replace(message, newline, space, -1))
        fmt.Println(c.conn.UnderlyingConn().RemoteAddr())
        fmt.Println(message)
    }
}

func (c *Client) writeWorker() {
    defer c.socket.Close()
    for msg := range c.send {
        err := c.socket.WriteMessage(websocket.TextMessage, msg) // will this work with JSON marshalling?
        if err != nil {
            log.Fatal(err)
            return
        }
    }
}

// This function should authenticate the client/user by determining proposed user role, obtaining
// and checking credentials, if necessary, and getting/generating an access token, and setting 
// a TTL (Time To Live) on it. Successful user logins should be logged with the Roster.
func (c *Client) handle112(msg map[int]interface{}) bool {
    // check if user is already logged in
        // if yes, check that the user is not already using an active client, maybe by pinging
            // any active client connection that is listed in the roster
    // check which user role is proposed
    // if Anon, assign nickname and log user-client mapping with roster
    // if Standard, authenticate credentials and then log user-client mapping with roster
}